import compose from 'koa-compose';

import createRoute from './routes';

// Function constants representing each URL scheme
const URL_WITH_NAME = name => `/${name}`;
const URL_WITH_PARAM = name => `/${name}/:${name}Param`;
const URL_EMPTY = () => '';

// Constant containing our actions
const ACTIONS = {
  'index': {
    method: 'get',
    url: URL_WITH_NAME,
    similar: ['create'],
    aliases: ['default', 'main'],
  },
  'show': {
    method: 'get',
    url: URL_WITH_PARAM,
    similar: ['update', 'destroy'],
    aliases: [],
  },
  'create': {
    method: 'post',
    url: URL_WITH_NAME,
    similar: ['index'],
    aliases: [],
  },
  'update': {
    method: 'put',
    url: URL_WITH_PARAM,
    similar: ['show', 'destroy'],
    aliases: [],
  },
  'destroy': {
    method: 'delete',
    url: URL_WITH_PARAM,
    similar: ['show', 'update'],
    aliases: [],
  },
};

/**
 * A recursive generator function that yields koa-route middlewares for each route.
 *
 * @param {Object} resources Contains all resources and their actions.
 * @param {String} prefix String to prepend to URL when generating routes.
 * @param {String} resourceName Name of the current resource we are processing.
 *
 * @return {Iterable}
 */
function* getMiddlewares(resources, prefix = '', resourceName = '') {
  // If our resources object is null, return
  if (resources === null || typeof resources !== 'object') return;

  // Create an array of arrays of related actions.
  const groupedActions = Object.keys(ACTIONS)
    .map(action => [ action, ...ACTIONS[action].aliases ]);

  // Reduce groupedActions to get one giant list of actions.
  const reducedActions = groupedActions
    .reduce((prev, action) => prev.concat(action), []);

  // Extract resource keys, and remove any key that starts in an underscore and isn't a function.
  const resourceKeys = Object.keys(resources)
    .filter(action => action[0] !== '_')
    .filter(key => typeof resources[key] === 'function' || typeof resources[key] === 'object');

  // Get a list of actions/aliases that are used in this resource that are functions.
  const actionList = reducedActions
    .filter(action => resourceKeys.indexOf(action) !== -1)
    .filter(action => typeof resources[action] === 'function');

  // Iterate through each action if we have at least one action
  if (actionList.length > 0) {
    // Checks if actions/aliases are mentioned in the same object twice.
    const duplicatedActions = groupedActions
      .map(actions => actionList.filter(action => actions.indexOf(action) !== -1))
      .filter(actions => actions.length > 1);

    // Perform invariant checks.
    if (duplicatedActions.length > 0) {
      throw Error(
        'The following methods mean the same thing and cannot be defined in the same object: ' +
          duplicatedActions[0].join(', ')
      );
    } else if (resourceName === '') {
      throw Error('The root resource object cannot contain actions.');
    }

    // Resolve alias names and make an array of routes to create
    const resolvedActions = actionList
      .map(action => ({
        name: groupedActions.filter(actions => actions.indexOf(action) !== -1)[0][0],
        alias: action,
      }))
      .map(action => ({
        ...action,
        handler: resources[action.alias],
        url: ACTIONS[action.name].url,
        method: ACTIONS[action.name].method,
      }));

    // List of URL types
    const urlTypes = [ URL_WITH_NAME, URL_WITH_PARAM ];

    // Iterate through each URL type
    for (const urlType of urlTypes) {
      // Generate object of methods to handlers for a given URL type
      const handlers = resolvedActions
        .filter(action => action.url === urlType)
        .reduce((prev, obj) => ({ ...prev, [obj.method]: obj.handler }), {});

      // Check if our list of handlers is not empty
      if (Object.keys(handlers).length !== 0) {
        yield createRoute(`${prefix}${urlType(resourceName)}`, handlers);
      }
    }
  }

  // Iterate through the rest of the methods (non-actions)
  for (const key of resourceKeys) {
    if (!reducedActions.includes(key)) {
      let url;

      // Decide which URL scheme to send down the recursive chain
      if (resourceName === '') {
        url = URL_EMPTY;
      } else if (actionList.length > 0) {
        url = URL_WITH_PARAM;
      } else {
        url = URL_WITH_NAME;
      }

      // Iterate through inner resources
      yield* getMiddlewares(resources[key], `${prefix}${url(resourceName)}`, key);
    }
  }
}

/**
 * Creates the middleware given resources and their actions.
 *
 * @param {Object} resources Contains all resources and their actions.
 *
 * @return {GeneratorFunction} The middleware.
 */
export default function resourceRoutes(resources) {
  // Use koa-compose on all REST middlewares generated by getMiddlewares
  return compose(Array.from(getMiddlewares(resources)));
}
